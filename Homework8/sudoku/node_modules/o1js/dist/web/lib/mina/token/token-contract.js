import { Int64 } from '../../int.js';
import { Provable } from '../../provable.js';
import { PublicKey } from '../../signature.js';
import { AccountUpdate, AccountUpdateForest, Permissions, } from '../../account-update.js';
import { SmartContract } from '../../zkapp.js';
import { TokenAccountUpdateIterator } from './forest-iterator.js';
export { TokenContract };
// it's fine to have this restriction, because the protocol also has a limit of ~20
// TODO find out precise protocol limit
const MAX_ACCOUNT_UPDATES = 20;
/**
 * Base token contract which
 * - implements the `Approvable` API, with the `approveBase()` method left to be defined by subclasses
 * - implements the `Transferable` API as a wrapper around the `Approvable` API
 */
class TokenContract extends SmartContract {
    // change default permissions - important that token contracts use an access permission
    deploy(args) {
        super.deploy(args);
        this.account.permissions.set({
            ...Permissions.default(),
            access: Permissions.proofOrSignature(),
        });
    }
    /**
     * Iterate through the account updates in `updates` and apply `callback` to each.
     *
     * This method is provable and is suitable as a base for implementing `approveUpdates()`.
     */
    forEachUpdate(updates, callback) {
        let iterator = TokenAccountUpdateIterator.create(updates, this.token.id);
        // iterate through the forest and apply user-defined logc
        for (let i = 0; i < MAX_ACCOUNT_UPDATES; i++) {
            let { accountUpdate, usesThisToken } = iterator.next();
            callback(accountUpdate, usesThisToken);
        }
        // prove that we checked all updates
        iterator.assertFinished(`Number of account updates to approve exceed ` +
            `the supported limit of ${MAX_ACCOUNT_UPDATES}.\n`);
        // skip hashing our child account updates in the method wrapper
        // since we just did that in the loop above
        this.approve(updates);
    }
    /**
     * Use `forEachUpdate()` to prove that the total balance change of child account updates is zero.
     *
     * This is provided out of the box as it is both a good example, and probably the most common implementation, of `approveBase()`.
     */
    checkZeroBalanceChange(updates) {
        let totalBalanceChange = Int64.zero;
        this.forEachUpdate(updates, (accountUpdate, usesToken) => {
            totalBalanceChange = totalBalanceChange.add(Provable.if(usesToken, accountUpdate.balanceChange, Int64.zero));
        });
        // prove that the total balance change is zero
        totalBalanceChange.assertEquals(0);
    }
    /**
     * Approve a single account update (with arbitrarily many children).
     */
    approveAccountUpdate(accountUpdate) {
        let forest = toForest([accountUpdate]);
        this.approveBase(forest);
    }
    /**
     * Approve a list of account updates (with arbitrarily many children).
     */
    approveAccountUpdates(accountUpdates) {
        let forest = toForest(accountUpdates);
        this.approveBase(forest);
    }
    // TRANSFERABLE API - simple wrapper around Approvable API
    /**
     * Transfer `amount` of tokens from `from` to `to`.
     */
    transfer(from, to, amount) {
        // coerce the inputs to AccountUpdate and pass to `approveUpdates()`
        let tokenId = this.token.id;
        if (from instanceof PublicKey) {
            from = AccountUpdate.defaultAccountUpdate(from, tokenId);
            from.requireSignature();
            from.label = `${this.constructor.name}.transfer() (from)`;
        }
        if (to instanceof PublicKey) {
            to = AccountUpdate.defaultAccountUpdate(to, tokenId);
            to.label = `${this.constructor.name}.transfer() (to)`;
        }
        from.balanceChange = Int64.from(amount).neg();
        to.balanceChange = Int64.from(amount);
        let forest = toForest([from, to]);
        this.approveBase(forest);
    }
}
function toForest(updates) {
    let trees = updates.map((a) => a instanceof AccountUpdate ? a.extractTree() : a);
    return AccountUpdateForest.from(trees);
}
//# sourceMappingURL=token-contract.js.map